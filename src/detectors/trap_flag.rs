use std::sync::atomic::{AtomicBool, Ordering};
use crate::ffi::trigger_trap_flag;
use crate::engine::policy::{DecisionEngine, DetectionSource};
use crate::engine::signal_compat;

static TRAP_WAS_HANDLED: AtomicBool = AtomicBool::new(false);

extern "C" fn trap_handler(_signum: libc::c_int, _info: *mut libc::siginfo_t, ctx: *mut libc::c_void) {
    TRAP_WAS_HANDLED.store(true, Ordering::SeqCst);
    
    // We MUST clear the Trap Flag (TF) in the saved context, otherwise
    // when the handler returns, it restores RFLAGS (with TF=1) and we get an infinite loop of SIGTRAP.
    unsafe {
        let ucontext = ctx as *mut libc::ucontext_t;
        // Access gregs. This is arch-specific (Linux x86_64).
        // libc::REG_EFL is the index for EFLAGS/RFLAGS.
        // We clear bit 8 (TF).
        (*ucontext).uc_mcontext.gregs[libc::REG_EFL as usize] &= !0x100;
    }
}

/// Uses the Trap Flag (TF) to detect a debugger.
/// By manually setting TF, we expect a SIGTRAP to be generated by the CPU.
/// If a debugger is attached, it will likely intercept this exception (thinking it's a breakpoint/step event)
/// and NOT pass it to our signal handler (unless the user manually passes it).
///
/// ## GDB Compatibility
/// 
/// When a tracer is detected via /proc/self/status, we skip the trap flag test
/// since it will conflict with the debugger's signal handling. Instead, we report
/// the detection based on tracer presence alone.
pub fn check_trap_flag(engine: &mut DecisionEngine) {
    // Check if a tracer is already attached
    let tracer_pid = signal_compat::get_tracer_pid();
    
    if tracer_pid > 0 {
        // A tracer is attached - skip the trap flag test to avoid conflicts
        // The tracer will intercept SIGTRAP and may not pass it to our handler
        eprintln!("[TRAP_FLAG] Tracer detected (PID {}), skipping trap flag test to avoid conflict", tracer_pid);
        
        // Report based on tracer presence - lower weight since we're inferring
        engine.report_with_confidence(
            DetectionSource::TrapFlag,
            40,  // Lower than direct detection (60)
            0.8, // High confidence in tracer presence
            &format!("Trap flag test skipped due to tracer (PID {})", tracer_pid)
        );
        return;
    }
    
    // No tracer detected - safe to run the trap flag test
    
    // 1. Register SIGTRAP handler
    unsafe {
        let mut sa: libc::sigaction = std::mem::zeroed();
        sa.sa_sigaction = trap_handler as *const () as usize;
        libc::sigemptyset(&mut sa.sa_mask);
        sa.sa_flags = libc::SA_SIGINFO; // Use SA_SIGINFO to get context
        
        if libc::sigaction(libc::SIGTRAP, &sa, std::ptr::null_mut()) != 0 {
            eprintln!("[TRAP_FLAG] Failed to register signal handler");
            return;
        }
    }

    // 2. Reset flag
    TRAP_WAS_HANDLED.store(false, Ordering::SeqCst);

    // 3. Trigger TF
    unsafe {
        trigger_trap_flag();
    }

    // 4. Check result
    if !TRAP_WAS_HANDLED.load(Ordering::SeqCst) {
        engine.report(
            DetectionSource::TrapFlag, 
            60, 
            "Trap Flag exception failed to trigger signal handler (Debugger intercepted?)"
        );
    }

    // 5. Restore default handler
    unsafe {
        libc::signal(libc::SIGTRAP, libc::SIG_DFL);
    }
}
